<jittershader name="bs.raymarch.jxs">
	<description>Spatial Augmented Reality Projection System - Shader</description>
	<param name="mode" type="int" default="0" />

	<param name="screen_m_matrix" type="mat4" state="WORLD_MATRIX" />
	<param name="offset_rot_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_rot_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_pos" type="vec3" default="0. 0. 0." />
	<param name="iGlobalTime" type="float" default="0." />

	<param name="tex0" type="int"/>
	<param name="tex1" type="int"/>

	<language name="glsl" version="1.2">
		<bind param="screen_m_matrix" program="vp" />
		<bind param="offset_rot_matrix" program="vp" />
		<bind param="cam0_rot_matrix" program="vp" />
		<bind param="cam0_pos" program="fp" />
		<bind param="iGlobalTime" program="fp" />
		
		<program name="vp" type="vertex">
<![CDATA[

#version 120

uniform vec3 cam0_pos;
uniform mat4 screen_m_matrix;
uniform mat4 cam0_rot_matrix;
uniform mat4 offset_rot_matrix;

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position


mat4 inv_trans_matrix = mat4(1.0, 0.0, 0.0, 0.0, 0, 1, 0, 0, 0, 0, 1, 0, -cam0_pos.x, -cam0_pos.y, -cam0_pos.z, 1);
mat4 trans_matrix = mat4(1.0, 0.0, 0.0, 0.0, 0, 1, 0, 0, 0, 0, 1, 0, cam0_pos.x, cam0_pos.y, cam0_pos.z, 1);

mat4 corrected_model_matrix = screen_m_matrix * trans_matrix * cam0_rot_matrix * offset_rot_matrix * inv_trans_matrix;

void main(void)
{
	// perform standard transform on vertex (general approach)
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
	
	gl_TexCoord[0]  = gl_TextureMatrix[0] * gl_MultiTexCoord0;
	
	normal = normalize(mat3(corrected_model_matrix) * gl_Normal);
	worldPos = vec3(corrected_model_matrix * gl_Vertex);
}

]]>		
		</program>
		<program name="fp" type="fragment">
<![CDATA[

uniform int mode;

// samplers
uniform vec3 cam0_pos;

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position

vec2 iMouse = vec2(0.5, 0.5);
vec2 iResolution = vec2(1000, 1000);

uniform float iGlobalTime;

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

// (c) 2016 xoihazard

#define TWO_PI 6.2831853072
#define PI 3.14159265359

const float timeScale = 0.2;
const float displace = 0.01;
const float gridSize = 20.0;
const float wave = 5.0;
const float brightness = 1.5;

vec2 rotate(in vec2 v, in float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return v * mat2(c, -s, s, c);
}

vec3 coordToHex(in vec2 coord, in float scale, in float angle) {
    vec2 c = rotate(coord, angle);
    float q = (1.0 / 3.0 * sqrt(3.0) * c.x - 1.0 / 3.0 * c.y) * scale;
    float r = 2.0 / 3.0 * c.y * scale;
    return vec3(q, r, -q - r);
}

vec3 hexToCell(in vec3 hex, in float m) {
    return fract(hex / m) * 2.0 - 1.0;
}

float absMax(in vec3 v) {
    return max(max(abs(v.x), abs(v.y)), abs(v.z));
}

float nsin(in float value) {
    return sin(value * TWO_PI) * 0.5 + 0.5;
}

float hexToFloat(in vec3 hex, in float amt) {
    return mix(absMax(hex), 1.0 - length(hex) / sqrt(3.0), amt);
}

float calc(in vec2 tx, in float time) {
    float angle = PI * nsin(time * 0.1) + PI / 6.0;
    float len = 1.0 - length(tx) * nsin(time);
    float value = 0.0;
    vec3 hex = coordToHex(tx, gridSize * nsin(time * 0.1), angle);

    for (int i = 0; i < 3; i++) {
        float offset = float(i) / 3.0;
        vec3 cell = hexToCell(hex, 1.0 + float(i));
        value += nsin(hexToFloat(cell,nsin(len + time + offset)) * 
                  wave * nsin(time * 0.5 + offset) + len + time);
    }

    return value / 3.0;
}


void main()
{
	vec3 viewline = cam0_pos - worldPos;
	vec3 vl_abs = abs(viewline);

    //vec2 tx = (fragCoord / iResolution.xy) - 0.5;
    //tx.x *= iResolution.x / iResolution.y;
    vec2 tx = viewline.xy;
    float time = iGlobalTime * timeScale;
    vec3 rgb = vec3(0.0, 0.0, 0.0);
    for (int i = 0; i < 3; i++) {
        float time2 = time + float(i) * displace;
        rgb[i] += pow(calc(tx, time2), 2.0);
    }
    gl_FragColor = vec4(rgb * brightness, 1.0);
}

//--------------------------------------------------------------------------

]]>
		</program>		
	</language>
</jittershader>
