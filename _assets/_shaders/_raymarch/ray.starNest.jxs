<jittershader name="bs.raymarch.jxs">
	<description>Spatial Augmented Reality Projection System - Shader</description>
	<param name="mode" type="int" default="0" />

	<param name="screen_m_matrix" type="mat4" state="WORLD_MATRIX" />
	<param name="offset_rot_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_rot_matrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="cam0_pos" type="vec3" default="0. 0. 0." />
	<param name="iGlobalTime" type="float" default="0." />

	<language name="glsl" version="1.2">
		<bind param="screen_m_matrix" program="vp" />
		<bind param="offset_rot_matrix" program="vp" />
		<bind param="cam0_rot_matrix" program="vp" />
		<bind param="cam0_pos" program="fp" />
		<bind param="iGlobalTime" program="fp" />
		
		<program name="vp" type="vertex">
<![CDATA[

#version 120

uniform vec3 cam0_pos;
uniform mat4 screen_m_matrix;
uniform mat4 cam0_rot_matrix;
uniform mat4 offset_rot_matrix;

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position


mat4 inv_trans_matrix = mat4(1.0, 0.0, 0.0, 0.0, 0, 1, 0, 0, 0, 0, 1, 0, -cam0_pos.x, -cam0_pos.y, -cam0_pos.z, 1);
mat4 trans_matrix = mat4(1.0, 0.0, 0.0, 0.0, 0, 1, 0, 0, 0, 0, 1, 0, cam0_pos.x, cam0_pos.y, cam0_pos.z, 1);

mat4 corrected_model_matrix = screen_m_matrix * trans_matrix * cam0_rot_matrix * offset_rot_matrix * inv_trans_matrix;

void main(void)
{
	// perform standard transform on vertex (general approach)
	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
	
	gl_TexCoord[0]  = gl_TextureMatrix[0] * gl_MultiTexCoord0;
	
	normal = normalize(mat3(corrected_model_matrix) * gl_Normal);
	worldPos = vec3(corrected_model_matrix * gl_Vertex);
}

]]>		
		</program>
		<program name="fp" type="fragment">
<![CDATA[

//uniform int mode;

// samplers
uniform vec3 cam0_pos;

varying vec3 normal;	// surface normal
varying vec3 worldPos;	// vertex world position

vec2 iMouse = vec2(0.5, 0.5);
vec2 iResolution = vec2(1000, 1000);

uniform float iGlobalTime;

// Star Nest by Pablo RomÃ¡n Andrioli

const float PI=3.14159265358979323846;

// This content is under the MIT License.

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850
#define speed  0.010 

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850


void main()
{
	vec3 viewline = cam0_pos - worldPos;
	vec3 vl_abs = abs(viewline);

	//get coords and direction
	//vec2 uv=fragCoord.xy/iResolution.xy-.5;
	//uv.y*=iResolution.y/iResolution.x;
	
	//vec3 dir=vec3(uv*zoom,1.);
	vec3 dir=viewline;
	
	float time=iGlobalTime*speed+.25;

	//mouse rotation
	//float a1=.5+iMouse.x/iResolution.x*2.;
	//float a2=.8+iMouse.y/iResolution.y*2.;
	float a1=.5+1.0*2.;
	float a2=.8+1.0*2.;
	mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));
	mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));
	dir.xz*=rot1;
	dir.xy*=rot2;
	vec3 from=vec3(1.,.5,0.5);
	from+=vec3(time*2.,time,-2.);
	from.xz*=rot1;
	from.xy*=rot2;
	
	//volumetric rendering
	float s=0.1,fade=1.;
	vec3 v=vec3(0.);
	for (int r=0; r<volsteps; r++) {
		vec3 p=from+s*dir*.5;
		p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold
		float pa,a=pa=0.;
		for (int i=0; i<iterations; i++) { 
			p=abs(p)/dot(p,p)-formuparam; // the magic formula
			a+=abs(length(p)-pa); // absolute sum of average change
			pa=length(p);
		}
		float dm=max(0.,darkmatter-a*a*.001); //dark matter
		a*=a*a; // add contrast
		if (r>6) fade*=1.-dm; // dark matter, don't render near
		//v+=vec3(dm,dm*.5,0.);
		v+=fade;
		v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance
		fade*=distfading; // distance fading
		s+=stepsize;
	}
	v=mix(vec3(length(v)),v,saturation); //color adjust
	gl_FragColor = vec4(v*.01,1.);	

//	int tint = mode * 1;
	
}

]]>
		</program>		
	</language>
</jittershader>
